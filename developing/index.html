<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Developing - Corpora</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../assets/_mkdocstrings.css" rel="stylesheet" />
        <link href="../style.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Developing";
        var mkdocs_page_input_path = "developing.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="..">
          <img src="../assets/logo.png" class="logo" alt="Logo"/>
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Getting Started</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../deploying/">Deploying</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../managing/">Managing</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">Developing</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#content-type-templates">Content Type Templates</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#editing-label-templates">Editing Label Templates</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#creating-new-templates">Creating New Templates</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#viewing-rendered-templates">Viewing Rendered Templates</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#corpus-api-for-python">Corpus API for Python</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#creating-a-corpus">Creating a Corpus</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#retrieving-a-corpus">Retrieving a Corpus</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#creating-content">Creating Content</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#retrieving-content">Retrieving Content</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#editing-content">Editing Content</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#deleting-content">Deleting Content</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#working-with-cross-referenced-content">Working with Cross-Referenced Content</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#working-with-files">Working with Files</a>
    </li>
        </ul>
    </li>
    </ul>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Corpora</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Developing</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="developing">Developing</h1>
<p>Corpora was built with the DH developer in mind just as much as the DH scholar. It was created as a way to flexibly handle a wide variety of DH projects with minimal effort while also empowering the developer to focus on the more innovative aspects of a given project. Below are detailed the affordances of corpora tailored specifically for developers, listed in order of complexity.</p>
<h2 id="content-type-templates">Content Type Templates</h2>
<p>From a developer's perspective, a <a href="/#content-type">Content Type</a> in Corpora is a class whose properties and methods are largely defined by the Content Type Manager (essentially a data schema editor) available on the Admin tab of a given corpus. Content Type Templates are the convention Corpora uses to allow developers to control how instances of content get <em>rendered</em>, whether as a textual label, an HTML snippet, a JavaScript component, an XML document, etc. This rendering is done using <a href="https://docs.djangoproject.com/en/5.0/ref/templates/">the Jinja2-style Django template convention</a>, and indeed it's recommended to refer to Django's documentation when editing or creating templates (particularly as a reference for <a href="https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#built-in-tag-reference">Django's built-in template tags</a>).</p>
<h3 id="editing-label-templates">Editing Label Templates</h3>
<p>By way of example, let's consider the following Content Type used to keep track of named entities throughout a corpus of XML documents:</p>
<p><img alt="Entity Content Type" src="../assets/img/content_type_templates_entity_example.png" title="Entity Content Type" /></p>
<p>There are four fields defined for this Content Type, which means any instance of this content will be an object with at least four properties. If we were to name an instance of this class <code>Entity</code>, then you'd access its four properties like this using pseudocode:</p>
<pre><code class="language-python">Entity.xml_id
Entity.entity_type
Entity.name
Entity.uris
</code></pre>
<p>There are also always three more hidden properties available for any instance of Content:</p>
<pre><code class="language-python">Entity.id       # a unique, alphanumeric identifier
Entity.uri      # a unique URI for this content which includes its corpus ID
Entity.label    # a textual representation of the content
</code></pre>
<p>The <code>label</code> property for any given piece of content in Corpora is generated using the template called "Label" which can be edited using the Content Type Manager.</p>
<p>To edit the Label template, go to the Admin tab of your corpus, scroll to the Content Type Manager, and expand out the tray for a given Content Type. Scroll to the bottom of that tray, and locate in the footer of the table that lists the fields for your Content Type the dropdown prefixed with the label "Edit Template." Click the "Go" button to begin editing the template used by Corpora to generate textual labels for that Content Type:</p>
<p><img alt="Template Editor" src="../assets/img/content_type_templates_label_example.png" title="Template Editor" /></p>
<p>In this particular case, the template for our label looks like this:</p>
<pre><code class="language-django">{{ Entity.name }} ({{ Entity.entity_type }})
</code></pre>
<p>When editing a Content Type template in Corpora, the template's "namespace" has available to it an instance of the content <em>named the same as the Content Type</em> (i.e. <code>Entity</code>). Django's templating system has a convention whereby you can dynamically insert the value for an object's property by surrounding it with double curly-braces. So to output the value of your Entity's <code>name</code> property in a template, you'd use:</p>
<pre><code class="language-django">{{ Entity.name }}
</code></pre>
<p>Notice this is how our template example begins. The rest of the example includes a space, open parenthesis, the output of the value for the Entity's <code>entity_type</code> field, and then a closing parenthesis. Given this template, if our instance of the Entity Content Type had the value "Maria Edgeworth" for the field <code>name</code>, and "PERSON" for the field <code>entity_type</code>, the textual label for that piece of content would look like this:</p>
<pre><code class="language-django">Maria Edgeworth (PERSON)
</code></pre>
<p>Django's templating system is powerful, as it also provides affordances for boolean logic in the form of if/else statements. Let's say we want our label template to be a little more sophisticated by having it provide default values for fields that have no value. In this case, we'll leverage Django's built-in <code>{% if ... %}</code> <a href="https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#if">syntax</a>:</p>
<pre><code class="language-django">{% if Entity.name %}{{ Entity.name }}{% else %}Unknown{% endif %} ({% if Entity.entity_type %}{{ Entity.entity_type }}{% else %}UNKNOWN{% endif %})
</code></pre>
<p>Using this new template, if the Entity's <code>name</code> property has no value, the string "Unknown" will be output. Similarly, if <code>entity_type</code> has no value, "UNKNOWN" will be output.</p>
<p>Note that when you make changes to a template in Corpora's Content Type Manager, you must click the orange "Save" button on the "Edit Template" modal, <em>and must also</em> click the orange "Save Changes" button in the footer of the Content Type Manager for template changes to be "committed" to your data schema. Also note that when the Label template is changed, Corpora automatically fires off a reindexing task for the Content Type in question, as well as for any other Content Types in your corpus that reference the Content Type in question. Depending on how many instances of these Content Types you have in your corpus, this reindexing may take some time.</p>
<h3 id="creating-new-templates">Creating New Templates</h3>
<p>Beyond specifying how content labels get created, Corpora's Content Type templating system allows you to create almost any kind of web-based representation of your content by allowing you to build a template and choose the appropriate <a href="https://en.wikipedia.org/wiki/Media_type">MIME type</a> for that representation.</p>
<p>Building off our <code>Entity</code> example, let's say you wanted to create <a href="https://tei-c.org/">TEI XML</a> representations for entities in your corpus. In the Content Type Manager for your corpus, you'd expand out the tray for your Content Type and, next to the "Go" button for editing an existing template, you'd click the "New Template" button to bring up the template editor:</p>
<p><img alt="XML Template Example" src="../assets/img/content_type_templates_xml_example.png" title="XML Template Example" /></p>
<p>Give your template a URL-friendly name (no spaces or special characters), provide the content for your template, and choose an appropriate MIME Type (in this case, text/xml so we can serve up XML for the output of this template). In case the image above is too small or blurry, here's the content for this template:</p>
<pre><code class="language-xml">&lt;person xml:id=&quot;{{ Entity.xml_id }}&quot;&gt;
   &lt;persName&gt;{{ Entity.name }}&lt;/persName&gt;
&lt;/person&gt;
</code></pre>
<p>Click the "Save" button on the template editing modal, and then click "Save Changes" at the bottom of the Content Type Manager. Once this happens, your new template is available to be rendered.</p>
<h3 id="viewing-rendered-templates">Viewing Rendered Templates</h3>
<p>To view the output of a template for an instance of content, you'll need to construct a URL that follows this convention:</p>
<pre><code class="language-html">[Your Corpora Instance]/corpus/[Corpus ID]/[Content Type]/[Content ID]/?render_template=[Template Name]
</code></pre>
<p>In this example, let's assume your Corpora instance is hosted at <code>https://mycorpora.org</code>, your Corpus ID is <code>62f554a9837071d8c4910dg</code>, the Content Type is <code>Entity</code>, the ID for your instance of Entity is <code>6691462b32399974cfc2cb1a</code>, and the template you want to render is our new <code>TEI-XML-Person</code> template. Given these assumptions, the URL would look like:</p>
<pre><code class="language-html">https://mycorpora.org/corpus/62f554a9837071d8c4910dg/Entity/6691462b32399974cfc2cb1a/?render_template=TEI-XML-Person
</code></pre>
<p>Your browser should then display the rendered output for your content as an XML document (screenshot from Google Chrome):</p>
<p><img alt="XML Output" src="../assets/img/content_type_templates_xml_output.png" title="XML Output" /></p>
<h2 id="corpus-api-for-python">Corpus API for Python</h2>
<p>The corpus API for Python does most of the heavy lifting behind the scenes in terms of the C.R.U.D. (creating, reading, updating, and deleting) operations on corpus data. Understanding how to use it is crucial to using the corpus iPython notebook and writing plugins for Corpora. At its heart, the API leverages <a href="https://docs.mongoengine.org/">MongoEngine</a>--an ORM for MongoDB designed to behave similarly to the <a href="https://docs.djangoproject.com/en/5.0/topics/db/models/">SQL-oriented ORM baked into Django</a>. In fact, each corpus or content object is a <a href="https://docs.mongoengine.org/guide/defining-documents.html">MongoEngine Document</a> under the hood, and when you query for content using the corpus API, you're actually working with <a href="https://docs.mongoengine.org/guide/querying.html">MongoEngine QuerySets</a>. As such, the majority of the documentation for the corpus API is covered by MongoEngine's documentation, so much of the documentation here will be in the form of examples.</p>
<h3 id="creating-a-corpus">Creating a Corpus</h3>
<pre><code class="language-python">from corpus import Corpus

my_corpus = Corpus()
my_corpus.name = &quot;MTC&quot;
my_corpus.description = &quot;My Test Corpus&quot;
my_corpus.save()
</code></pre>
<p>Upon running the above script, the <code>my_corpus</code> variable will be an instance of <a href="https://docs.mongoengine.org/apireference.html#mongoengine.Document">mongoengine.Document</a>. After saving it, the <code>id</code> property of <code>my_corpus</code> will be a BSON ObjectId, which is how MongoDB uniquely identifies each document. The alphanumeric string representation of the ObjectId can be acquired like so:</p>
<pre><code class="language-python">my_corpus_id_as_a_string = str(my_corpus.id)
</code></pre>
<h3 id="retrieving-a-corpus">Retrieving a Corpus</h3>
<pre><code class="language-python">from corpus import get_corpus

my_corpus = get_corpus('6661e28c4399e45f0bfd2121')
</code></pre>
<p>The <code>get_corpus</code> function will accept as its first parameter either a string or a BSON ObjectId and will return an instance of the Corpus object, which is ultimately a MongoEngine Document with the following properties:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Data Type</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>string</td>
<td>To provide a brief project label, typically an acronym.</td>
</tr>
<tr>
<td>description</td>
<td>string</td>
<td>To provide a full project descriptor, typically the spelled out version of the project's name.</td>
</tr>
<tr>
<td>uri</td>
<td>string</td>
<td>This property is generated when the corpus is first saved, and it provides a unique URI for the corpus as it exists on the instance of Corpora hosting it.</td>
</tr>
<tr>
<td>path</td>
<td>string</td>
<td>Generated upon first save. It contains the file path to the corpus' files within the Corpora Docker container, should it have any.</td>
</tr>
<tr>
<td>kvp</td>
<td>dictionary</td>
<td>KVP stands for "key/value pairs," and it's intended to house arbitrary metadata (rarely used).</td>
</tr>
<tr>
<td>files</td>
<td>dictionary</td>
<td>The keys for the dictionary are unique hashes based on the file's path. These are long alphanumeric strings. The values are <a href="#Files">File objects</a>.</td>
</tr>
<tr>
<td>repos</td>
<td>dictionary</td>
<td>The keys are the name given to the repo, and the values are <a href="/#repos">Repo objects</a>.</td>
</tr>
<tr>
<td>open_access</td>
<td>boolean</td>
<td>A flag for determining whether a corpus is open access, making its read-only API publicly available.</td>
</tr>
<tr>
<td>content_types</td>
<td>dictionary</td>
<td>The keys are the name of a given Content Type, and the values are a dictionary specifying the metadata for a given Content Type and its fields.</td>
</tr>
<tr>
<td>provenance</td>
<td>list</td>
<td>A list of completed jobs for this corpus.</td>
</tr>
</tbody>
</table>
<p>A corpus object also has several methods which will be covered in subsequent sections.</p>
<h3 id="creating-content">Creating Content</h3>
<p>With a corpus object in hand, you can create content using the corpus' <code>get_content</code> method. This example assumes you have a Content Type called "Document" in your corpus:</p>
<pre><code class="language-python">new_document = my_corpus.get_content('Document')
new_document.title = &quot;On Beauty&quot;
new_document.author = &quot;Zadie Smith&quot;
new_document.save()
</code></pre>
<p>Calling your corpus' <code>get_content</code> method by only passing in the Content Type name will return an instance of a MongoEngine document with that Content Type's fields as properties to be set. Once you've set those field values, you call the <code>save</code> method to save the content and assign it a unique ID.</p>
<p><em>Note:</em> When saving content, the data is first saved to MongoDB. Post-save events then fire which also <em>index</em> the content in Elasticsearch and <em>link</em> the data in Neo4J. As such, saving content can be relatively time consuming, especially when saving in bulk. In cases where bulk saving needs to occur, you can turn off indexing and/or linking like so:</p>
<pre><code class="language-python"># Saves to MongoDB and Neo4J, but not Elasticsearch:
new_document.save(do_indexing=False)

# Saves to MongoDB and Elasticsearch, but not Neo4J:
new_document.save(do_linking=False) 

# Saves only to MongoDB:
new_document.save(do_indexing=False, do_linking=False)
</code></pre>
<p>If you later want to fire off a job to index and link all of your content, you can do so like this:</p>
<pre><code class="language-python">my_corpus.queue_local_job(task_name=&quot;Adjust Content&quot;, parameters={
    'content_type': 'Document',
    'reindex': True,
    'relabel': True
})
</code></pre>
<h3 id="retrieving-content">Retrieving Content</h3>
<p>Your corpus' <code>get_content</code> method is also useful for retrieving content when you know either the ID or exact field values for your content. When using <code>get_content</code> to retrieve content, you're ultimately querying MongoDB:</p>
<pre><code class="language-python"># Query for a single piece of content with the ID known:
content = my_corpus.get_content('Document', '5f623f2a52023c009d73108e')
print(content.title)
&quot;On Beauty&quot;

# Query for a single piece of content by field value:
content = my_corpus.get_content('Document', {'title': &quot;On Beauty&quot;}, single_result=True)

# Query for multiple pieces of content by field value:
contents = my_corpus.get_content('Document', {'author': &quot;Zadie Smith&quot;})
for content in contents:
    print(content.title)
&quot;White Teeth&quot;
&quot;On Beauty&quot;

# Query for all content with this Content Type:
contents = my_corpus.get_content('Document', all=True)
</code></pre>
<p>When retrieving a single piece of content, you receive a MongoEngine Document. When retrieving multiple pieces of content, you receive a MongoEngine QuerySet. QuerySets are generators (can be iterated over using a for-loop), but also have their own methods, like <code>count</code>:</p>
<pre><code class="language-python">contents = my_corpus.get_content('Document', all=True)
contents.count()
42
</code></pre>
<h3 id="editing-content">Editing Content</h3>
<p>Once you've retrieved a single piece of content using <code>get_content</code>, you can directly edit its field values and then call <code>save</code> to edit it:</p>
<pre><code class="language-python">content = my_corpus.get_content('Document', '5f623f2a52023c009d73108e')
content.published_year = 2005
content.save()
</code></pre>
<h3 id="deleting-content">Deleting Content</h3>
<p>Deleting content is as simple as calling the MongoEngine Document's <code>delete</code> method:</p>
<pre><code class="language-python">content = my_corpus.get_content('Document', '5f623f2a52023c009d73108e')
content.delete()
</code></pre>
<p><em>Note:</em> because content can be cross-referenced in arbitrary ways, deleting content saves a stub in the database that tells Corpora to sweep for instances of other content that references the deleted content so as to remove those references. When deleting large quantities of content, this can cause a backlog of deletion stubs. If you know you'll be deleting a large amount of content, and you also feel certain there's no need to track these deletions in order to hunt for stale content references, you can skip the creation of a deletion stub like so:</p>
<pre><code class="language-python">content.delete(track_deletions=False)
</code></pre>
<h3 id="working-with-cross-referenced-content">Working with Cross-Referenced Content</h3>
<p>Much of the value of Corpora's Neo4J database is in its ability to keep track of the way your content is related, allowing the interface to visualize these connections. Content becomes "related" to other content via fields of type <code>cross-reference</code>.</p>
<p>By way of example, let's assume you're working with a corpus that has two Content Types: <code>Entity</code> and <code>Letter</code>. And let's say that the <code>Letter</code> has a field called <code>recipient</code> of type <code>cross-reference</code> that specifically references the type <code>Entity</code>. In this way, a <code>Letter</code> can reference a specific <code>Entity</code> via its <code>recipient</code> field. Let's create an Entity and a Letter, and "relate" them appropriately:</p>
<pre><code class="language-python">entity = my_corpus.get_content('Entity')
entity.name = &quot;Elizabeth Barrett Browning&quot;
entity.save()

letter = my_corpus.get_content('Letter')
letter.contents = &quot;Real warm spring, dear Miss Barrett, and the birds know it, and in Spring I shall see you, really see you...&quot;
letter.recipient = entity.id
letter.save()
</code></pre>
<p>Note how when specifying the value of the <code>recipient</code> field for our instance of <code>Letter</code>, we used the <code>id</code> property of <code>Entity</code>. If the "multiple" box is checked when creating a field of type <code>cross-reference</code>, the field is actually a list, and so content ID's must be appended to the list:</p>
<pre><code class="language-python">letter.recipients.append(entity.id)
letter.save()
</code></pre>
<p>You may query for content using cross-referenced fields, and the easiest way to do this is with the ObjectId (or its string representation) of the cross-referenced content. For example:</p>
<pre><code class="language-python">letters_to_elizabeth = my_corpus.get_content('Letter', {'recipient': '66a166e56cf2fb23103b58b2'})
</code></pre>
<p>You may also access the values of nested fields for cross-referenced content like so:</p>
<pre><code class="language-python">first_letter = letters_to_elizabeth[0]
print(first_letter.recipient.name)
&quot;Elizabeth Barrett Browning&quot;
</code></pre>
<h3 id="working-with-files">Working with Files</h3>
<p>In Corpora, files belonging to a corpus or to a piece of content are ultimately registered as <code>File</code> objects, which themselves are a MongoEngine Embedded Document with the following properties:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Data Type</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>path</td>
<td>string</td>
<td>To keep track of the file path as it exists inside the Corpora container.</td>
</tr>
<tr>
<td>primary_witness</td>
<td>boolean</td>
<td>To flag whether the file should be the primary "witness" or digital surrogate for the content in question. Currently only used in the context of the <code>Document</code> plugin.</td>
</tr>
<tr>
<td>basename</td>
<td>string</td>
<td>The filename of the file (without the path), i.e. "data.csv"</td>
</tr>
<tr>
<td>extension</td>
<td>string</td>
<td>The extension of the file, i.e. "csv"</td>
</tr>
<tr>
<td>byte_size</td>
<td>integer</td>
<td>The size of the file in bytes</td>
</tr>
<tr>
<td>description</td>
<td>string</td>
<td>Human-readable description of the file</td>
</tr>
<tr>
<td>provenance_type</td>
<td>string</td>
<td>To track what kind of thing originated this file, i.e. "Tesseract OCR Job"</td>
</tr>
<tr>
<td>provenance_id</td>
<td>string</td>
<td>A unique identifier for the thing that originated this file, i.e. "4213"</td>
</tr>
<tr>
<td>height</td>
<td>integer</td>
<td>The height in pixels of the file (if it's an image)</td>
</tr>
<tr>
<td>width</td>
<td>integer</td>
<td>The width in pixels of the file (if it's an image)</td>
</tr>
<tr>
<td>iiif_info</td>
<td>dict</td>
<td>A dictionary representing the kind of metadata you get when querying for /info.json on a IIIF server</td>
</tr>
</tbody>
</table>
<p>While those properties can be helpful, the only required property when creating a <code>File</code> object to represent a file is the <code>path</code>. The path of a file is always relative to the Corpora container. When the file is directly associated with a corpus, it lives in the <code>/files</code> directory, itself living in the directory specified by the corpus' <code>path</code> property. A directory is created in the Corpora container any time a corpus is created, and its path always looks like <code>/corpora/[corpus ID]</code>. As such, files directly associated with a corpus should live inside the <code>/corpus/[corpus ID]/files</code> directory.</p>
<p>The best way to associate a file with a corpus is via the corpus' homepage by going to the "Metadata" tab and clicking the orange "Import" button next to "Corpus Files." When you import files like this, it saves them in a <code>files</code> directory living inside of the directory specified in the <code>path</code> property of the corpus. Imported files are also registered in the <code>files</code> dictionary of your corpus object.</p>
<p>The keys for the <code>files</code> dictionary of a corpus are hashes based on the file's path--this is to provide a URL-friendly way of accessing them. This makes retrieving them programmatically in Python a little unintuitive, however. Let's say you upload a file called <code>entities.csv</code> to your corpus. To access that file with Python, you'll need to get its path like so:</p>
<pre><code class="language-python">entities_csv_path = None
for file_key in my_corpus.files.keys():
    if 'entities.csv' in my_corpus.files[file_key].path:
        entities_csv_path = my_corpus.files[file_key].path
</code></pre>
<p>Content Types can also specify "File" as a type of field, and in those cases, you may directly access the <code>path</code> property of the file (no intervening dictionary with file key hashes):</p>
<pre><code class="language-python">photo = my_corpus.get_content('Photo', '66a166e56cf2fb23103b6h7')
photo.original_file.path
</code></pre>
<p>When files belong to an instance of content (rather than directly associated with a corpus), that piece of content gets its own <code>path</code> property and a directory is created for it (directories are normally not created for content--only when they have files associated with them). Content paths always look like this:</p>
<p><code>/corpora/[corpus ID]/[Content Type]/[breakout directory]/[content ID]</code></p>
<p>Given that millions of instances of a Content Type could exist for a corpus, Corpora implements a "breakout directory" to prevent any one directory from containing millions of subdirectories!</p>
<p>Much like with a corpus, files associated with content live inside the <code>/files</code> subdirectory of a content instance's path, i.e.:</p>
<p><code>/corpora/[corpus ID]/[Content Type]/[breakout directory]/[content ID]/files</code></p>
<p>When programmatically associating a file to a corpus or piece of content, it's important for that file to live in the correct place, as this allows all the files belonging to a corpus to be exported and restored appropriately.</p>
<p>To programmatically associate a file directly with a corpus, first upload it to the corpus' appropriate <code>/files</code> subdirectory and make note of its full path. Then:</p>
<pre><code class="language-python">from corpus import get_corpus, File

# store the path to the file in a variable
my_file_path = '/corpora/6661e28c4399e45f0bfd2121/files/data.csv'

# retrieve your corpus
my_corpus = get_corpus('6661e28c4399e45f0bfd2121')

# create an instance of the File object by using its &quot;process&quot; method
# which takes at minimum the path to the file
my_file = File.process(my_file_path)

# generate a file key for storing the file in the corpus
my_file_key = File.generate_key(my_file_path)

my_corpus.files[my_file_key] = my_file
my_corpus.save()
</code></pre>
<p>Note the use of the <code>process</code> class method of File. That method takes a file path, checks to see if the file exists, gathers some minimal metadata about the file (like file size), and returns a <code>File</code> object. Because files directly associated with a corpus are stored using a file key, we generate one with the <code>generate_key</code> method of File.</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../managing/" class="btn btn-neutral float-left" title="Managing"><span class="icon icon-circle-arrow-left"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../managing/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
